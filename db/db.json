[
  {
    "title": "C#",
    "text": "GENERAL INFORMATION\nOpen source in 2014 and can be used to build apps outside of the .NET framework -- Desktop, Web, Cloud, Mobile, Games, IOT, and AI\nObject Oriented Language but supports Functional patterns and has the ability to write a declarative query on any data-structure with a feature called LINQ.\nC# Is a memory safe language and uses garbage collection. Garbage Collection automatically reclaims memory that is no longer needed by the program. This shifts the responsibility of memory management form the programmer to the runtime environment.\nStatically typed language\nTo organize code and share code it is wrapped in a namespace\nCreate new classes inside name spaces that have constructors and deconstructors\n\n\n\nCOMPILING\nC# code is compiled into an intermediate language CIL (Common intermediate Language) or MSIL (Microsoft Intermediate Language). \nThe resulting CIL code is then executed by the CLR (Common Language Runtime Environment) which just-in-time (JIT) compiles it into machine code\nJIT is a part of the Common Language Runtime in .NET. The machine code is then executed by the target system's processor.\nThis architecture enables C# programs to be platform-independent, as long as the platform has .NET framework installed.\n\nGARBAGE COLLECTION\n1. ALLOCATION: When objects are created in memory (through object instantiation) memory is allocated to store those objects\n\n2. USAGE: The program uses and manipulates these objects as needed\n\n3. DETERMINATION OF REACHABILITY: The garbage collector periodically examines the objects in memory to determine which ones are no longer accessible or reachable by the program. Objects that are not reachable from any active part of the program are considered garbage.\n\n4. RECLAMATION: Once the garbage collector identifies unreferenced objects, it reclaims their memory by deallocating them. This memory is then made available for future allocations.\n\nGarbage collection helps prevent memory leaks and dangling pointers, which are common sources of bugs and vulnerabilities in programs, however, it can introduce overhead due to the need for periodic garbage collection cycles, potentially impacting performance.\n\nDATA TYPES\nint: 32-bit signed integers\nlong: 64-bit signed integers\nfloat: single-precision floating-point numbers\ndouble: double-precision floating-point numbers\ndecimal: decimal numbers with higher precision\nbool: true or false\nchar: single Unicode character\nbyte: 8-bit unsigned integer\nsbyte: 8-bit signed integer\nshort: 16-bit signed integer\nushort: 18-bit unsigned integers\nuint: 32-bit unsigned integers\nulong: 64-bit unsigned integers\nstring: sequence of characters\nenum: set of named constants ( enum Days {Sunday, Monday, Tuesday, Wednesday}.\nobjects: represent any type in c# and is the base of all other types\ndynamic: type whose operations are not resolved until runtime\nClasses: User-defined reference types that can contain data members and member functions\nInterfaces: defines a contract for implementing classes\nDelegates: represents a reference to a method\nNullable:\n\nINTERFACES\nInterface defines a “Contract” that all the classes inheriting from should follow\nAn interface declares “What a class should have”\nAn inheriting class defines “How it should do it”\nBenefit = Security + Multiple inheritance + “plug-and-play”\n\nCreate base interfaces (Example: Interface IPredator or Interface IPrey)\nCreate classes off of those instances (Class Fish : IPrey or Class Wolf : IPredator)\n\n",
    "id": "7e226936-a962-4852-8b97-3b0f74de8c3c"
  },
  {
    "title": "Test",
    "text": "Test",
    "id": "8365ce31-0d6b-4590-96c1-30b3b8ba8677"
  }
]